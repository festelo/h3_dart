// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings to H3
class H3C {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  H3C(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  H3C.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// @defgroup describeH3Error describeH3Error
  /// Functions for describeH3Error
  /// @{
  /// /
  /// /** @brief converts the provided H3Error value into a description string
  ffi.Pointer<ffi.Char> describeH3Error(
    int err,
  ) {
    return _describeH3Error(
      err,
    );
  }

  late final _describeH3ErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Uint32)>>(
          'describeH3Error');
  late final _describeH3Error =
      _describeH3ErrorPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// @defgroup latLngToCell latLngToCell
  /// Functions for latLngToCell
  /// @{
  /// /
  /// /** @brief find the H3 index of the resolution res cell containing the lat/lng
  int latLngToCell(
    ffi.Pointer<LatLng> g,
    int res,
    ffi.Pointer<ffi.Uint64> out,
  ) {
    return _latLngToCell(
      g,
      res,
      out,
    );
  }

  late final _latLngToCellPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(ffi.Pointer<LatLng>, ffi.Int,
              ffi.Pointer<ffi.Uint64>)>>('latLngToCell');
  late final _latLngToCell = _latLngToCellPtr.asFunction<
      int Function(ffi.Pointer<LatLng>, int, ffi.Pointer<ffi.Uint64>)>();

  /// @defgroup cellToLatLng cellToLatLng
  /// Functions for cellToLatLng
  /// @{
  /// /
  /// /** @brief find the lat/lng center point g of the cell h3
  int cellToLatLng(
    int h3,
    ffi.Pointer<LatLng> g,
  ) {
    return _cellToLatLng(
      h3,
      g,
    );
  }

  late final _cellToLatLngPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Uint64, ffi.Pointer<LatLng>)>>('cellToLatLng');
  late final _cellToLatLng =
      _cellToLatLngPtr.asFunction<int Function(int, ffi.Pointer<LatLng>)>();

  /// @defgroup cellToBoundary cellToBoundary
  /// Functions for cellToBoundary
  /// @{
  /// /
  /// /** @brief give the cell boundary in lat/lng coordinates for the cell h3
  int cellToBoundary(
    int h3,
    ffi.Pointer<CellBoundary> gp,
  ) {
    return _cellToBoundary(
      h3,
      gp,
    );
  }

  late final _cellToBoundaryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Uint64, ffi.Pointer<CellBoundary>)>>('cellToBoundary');
  late final _cellToBoundary = _cellToBoundaryPtr
      .asFunction<int Function(int, ffi.Pointer<CellBoundary>)>();

  /// @defgroup gridDisk gridDisk
  /// Functions for gridDisk
  /// @{
  /// /
  /// /** @brief maximum number of hexagons in k-ring
  int maxGridDiskSize(
    int k,
    ffi.Pointer<ffi.Int64> out,
  ) {
    return _maxGridDiskSize(
      k,
      out,
    );
  }

  late final _maxGridDiskSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Int, ffi.Pointer<ffi.Int64>)>>('maxGridDiskSize');
  late final _maxGridDiskSize = _maxGridDiskSizePtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Int64>)>();

  /// @brief hexagons neighbors in all directions, assuming no pentagons
  int gridDiskUnsafe(
    int origin,
    int k,
    ffi.Pointer<ffi.Uint64> out,
  ) {
    return _gridDiskUnsafe(
      origin,
      k,
      out,
    );
  }

  late final _gridDiskUnsafePtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Uint64, ffi.Int, ffi.Pointer<ffi.Uint64>)>>('gridDiskUnsafe');
  late final _gridDiskUnsafe = _gridDiskUnsafePtr
      .asFunction<int Function(int, int, ffi.Pointer<ffi.Uint64>)>();

  /// @brief hexagons neighbors in all directions, assuming no pentagons,
  /// reporting distance from origin
  int gridDiskDistancesUnsafe(
    int origin,
    int k,
    ffi.Pointer<ffi.Uint64> out,
    ffi.Pointer<ffi.Int> distances,
  ) {
    return _gridDiskDistancesUnsafe(
      origin,
      k,
      out,
      distances,
    );
  }

  late final _gridDiskDistancesUnsafePtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(ffi.Uint64, ffi.Int, ffi.Pointer<ffi.Uint64>,
              ffi.Pointer<ffi.Int>)>>('gridDiskDistancesUnsafe');
  late final _gridDiskDistancesUnsafe = _gridDiskDistancesUnsafePtr.asFunction<
      int Function(int, int, ffi.Pointer<ffi.Uint64>, ffi.Pointer<ffi.Int>)>();

  /// @brief hexagons neighbors in all directions reporting distance from origin
  int gridDiskDistancesSafe(
    int origin,
    int k,
    ffi.Pointer<ffi.Uint64> out,
    ffi.Pointer<ffi.Int> distances,
  ) {
    return _gridDiskDistancesSafe(
      origin,
      k,
      out,
      distances,
    );
  }

  late final _gridDiskDistancesSafePtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(ffi.Uint64, ffi.Int, ffi.Pointer<ffi.Uint64>,
              ffi.Pointer<ffi.Int>)>>('gridDiskDistancesSafe');
  late final _gridDiskDistancesSafe = _gridDiskDistancesSafePtr.asFunction<
      int Function(int, int, ffi.Pointer<ffi.Uint64>, ffi.Pointer<ffi.Int>)>();

  /// @brief collection of hex rings sorted by ring for all given hexagons
  int gridDisksUnsafe(
    ffi.Pointer<ffi.Uint64> h3Set,
    int length,
    int k,
    ffi.Pointer<ffi.Uint64> out,
  ) {
    return _gridDisksUnsafe(
      h3Set,
      length,
      k,
      out,
    );
  }

  late final _gridDisksUnsafePtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(ffi.Pointer<ffi.Uint64>, ffi.Int, ffi.Int,
              ffi.Pointer<ffi.Uint64>)>>('gridDisksUnsafe');
  late final _gridDisksUnsafe = _gridDisksUnsafePtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Uint64>, int, int, ffi.Pointer<ffi.Uint64>)>();

  /// @brief hexagon neighbors in all directions
  int gridDisk(
    int origin,
    int k,
    ffi.Pointer<ffi.Uint64> out,
  ) {
    return _gridDisk(
      origin,
      k,
      out,
    );
  }

  late final _gridDiskPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Uint64, ffi.Int, ffi.Pointer<ffi.Uint64>)>>('gridDisk');
  late final _gridDisk = _gridDiskPtr
      .asFunction<int Function(int, int, ffi.Pointer<ffi.Uint64>)>();

  /// @defgroup gridDiskDistances gridDiskDistances
  /// Functions for gridDiskDistances
  /// @{
  /// /
  /// /** @brief hexagon neighbors in all directions, reporting distance from origin
  int gridDiskDistances(
    int origin,
    int k,
    ffi.Pointer<ffi.Uint64> out,
    ffi.Pointer<ffi.Int> distances,
  ) {
    return _gridDiskDistances(
      origin,
      k,
      out,
      distances,
    );
  }

  late final _gridDiskDistancesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(ffi.Uint64, ffi.Int, ffi.Pointer<ffi.Uint64>,
              ffi.Pointer<ffi.Int>)>>('gridDiskDistances');
  late final _gridDiskDistances = _gridDiskDistancesPtr.asFunction<
      int Function(int, int, ffi.Pointer<ffi.Uint64>, ffi.Pointer<ffi.Int>)>();

  /// @defgroup gridRingUnsafe gridRingUnsafe
  /// Functions for gridRingUnsafe
  /// @{
  /// /
  /// /** @brief hollow hexagon ring at some origin
  int gridRingUnsafe(
    int origin,
    int k,
    ffi.Pointer<ffi.Uint64> out,
  ) {
    return _gridRingUnsafe(
      origin,
      k,
      out,
    );
  }

  late final _gridRingUnsafePtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Uint64, ffi.Int, ffi.Pointer<ffi.Uint64>)>>('gridRingUnsafe');
  late final _gridRingUnsafe = _gridRingUnsafePtr
      .asFunction<int Function(int, int, ffi.Pointer<ffi.Uint64>)>();

  /// @defgroup polygonToCells polygonToCells
  /// Functions for polygonToCells
  /// @{
  /// /
  /// /** @brief maximum number of cells that could be in the polygon
  int maxPolygonToCellsSize(
    ffi.Pointer<GeoPolygon> geoPolygon,
    int res,
    int flags,
    ffi.Pointer<ffi.Int64> out,
  ) {
    return _maxPolygonToCellsSize(
      geoPolygon,
      res,
      flags,
      out,
    );
  }

  late final _maxPolygonToCellsSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(ffi.Pointer<GeoPolygon>, ffi.Int, ffi.Uint32,
              ffi.Pointer<ffi.Int64>)>>('maxPolygonToCellsSize');
  late final _maxPolygonToCellsSize = _maxPolygonToCellsSizePtr.asFunction<
      int Function(
          ffi.Pointer<GeoPolygon>, int, int, ffi.Pointer<ffi.Int64>)>();

  /// @brief cells within the given polygon
  int polygonToCells(
    ffi.Pointer<GeoPolygon> geoPolygon,
    int res,
    int flags,
    ffi.Pointer<ffi.Uint64> out,
  ) {
    return _polygonToCells(
      geoPolygon,
      res,
      flags,
      out,
    );
  }

  late final _polygonToCellsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(ffi.Pointer<GeoPolygon>, ffi.Int, ffi.Uint32,
              ffi.Pointer<ffi.Uint64>)>>('polygonToCells');
  late final _polygonToCells = _polygonToCellsPtr.asFunction<
      int Function(
          ffi.Pointer<GeoPolygon>, int, int, ffi.Pointer<ffi.Uint64>)>();

  /// @defgroup polygonToCellsExperimental polygonToCellsExperimental
  /// Functions for polygonToCellsExperimental.
  /// This is an experimental-only API and is subject to change in minor versions.
  /// @{
  /// /
  /// /** @brief maximum number of cells that could be in the polygon
  int maxPolygonToCellsSizeExperimental(
    ffi.Pointer<GeoPolygon> polygon,
    int res,
    int flags,
    ffi.Pointer<ffi.Int64> out,
  ) {
    return _maxPolygonToCellsSizeExperimental(
      polygon,
      res,
      flags,
      out,
    );
  }

  late final _maxPolygonToCellsSizeExperimentalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(ffi.Pointer<GeoPolygon>, ffi.Int, ffi.Uint32,
              ffi.Pointer<ffi.Int64>)>>('maxPolygonToCellsSizeExperimental');
  late final _maxPolygonToCellsSizeExperimental =
      _maxPolygonToCellsSizeExperimentalPtr.asFunction<
          int Function(
              ffi.Pointer<GeoPolygon>, int, int, ffi.Pointer<ffi.Int64>)>();

  /// @brief cells within the given polygon
  int polygonToCellsExperimental(
    ffi.Pointer<GeoPolygon> polygon,
    int res,
    int flags,
    int size,
    ffi.Pointer<ffi.Uint64> out,
  ) {
    return _polygonToCellsExperimental(
      polygon,
      res,
      flags,
      size,
      out,
    );
  }

  late final _polygonToCellsExperimentalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Pointer<GeoPolygon>,
              ffi.Int,
              ffi.Uint32,
              ffi.Int64,
              ffi.Pointer<ffi.Uint64>)>>('polygonToCellsExperimental');
  late final _polygonToCellsExperimental =
      _polygonToCellsExperimentalPtr.asFunction<
          int Function(ffi.Pointer<GeoPolygon>, int, int, int,
              ffi.Pointer<ffi.Uint64>)>();

  /// @defgroup cellsToMultiPolygon cellsToMultiPolygon
  /// Functions for cellsToMultiPolygon (currently a binding-only concept)
  /// @{
  /// /
  /// /** @brief Create a LinkedGeoPolygon from a set of contiguous hexagons
  int cellsToLinkedMultiPolygon(
    ffi.Pointer<ffi.Uint64> h3Set,
    int numHexes,
    ffi.Pointer<LinkedGeoPolygon> out,
  ) {
    return _cellsToLinkedMultiPolygon(
      h3Set,
      numHexes,
      out,
    );
  }

  late final _cellsToLinkedMultiPolygonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(ffi.Pointer<ffi.Uint64>, ffi.Int,
              ffi.Pointer<LinkedGeoPolygon>)>>('cellsToLinkedMultiPolygon');
  late final _cellsToLinkedMultiPolygon =
      _cellsToLinkedMultiPolygonPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Uint64>, int, ffi.Pointer<LinkedGeoPolygon>)>();

  /// @brief Free all memory created for a LinkedGeoPolygon
  void destroyLinkedMultiPolygon(
    ffi.Pointer<LinkedGeoPolygon> polygon,
  ) {
    return _destroyLinkedMultiPolygon(
      polygon,
    );
  }

  late final _destroyLinkedMultiPolygonPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LinkedGeoPolygon>)>>(
      'destroyLinkedMultiPolygon');
  late final _destroyLinkedMultiPolygon = _destroyLinkedMultiPolygonPtr
      .asFunction<void Function(ffi.Pointer<LinkedGeoPolygon>)>();

  /// @defgroup degsToRads degsToRads
  /// Functions for degsToRads
  /// @{
  /// /
  /// /** @brief converts degrees to radians
  double degsToRads(
    double degrees,
  ) {
    return _degsToRads(
      degrees,
    );
  }

  late final _degsToRadsPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>(
          'degsToRads');
  late final _degsToRads = _degsToRadsPtr.asFunction<double Function(double)>();

  /// @defgroup radsToDegs radsToDegs
  /// Functions for radsToDegs
  /// @{
  /// /
  /// /** @brief converts radians to degrees
  double radsToDegs(
    double radians,
  ) {
    return _radsToDegs(
      radians,
    );
  }

  late final _radsToDegsPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>(
          'radsToDegs');
  late final _radsToDegs = _radsToDegsPtr.asFunction<double Function(double)>();

  /// @defgroup greatCircleDistance greatCircleDistance
  /// Functions for distance
  /// @{
  /// /
  /// /** @brief "great circle distance" between pairs of LatLng points in radians
  double greatCircleDistanceRads(
    ffi.Pointer<LatLng> a,
    ffi.Pointer<LatLng> b,
  ) {
    return _greatCircleDistanceRads(
      a,
      b,
    );
  }

  late final _greatCircleDistanceRadsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<LatLng>,
              ffi.Pointer<LatLng>)>>('greatCircleDistanceRads');
  late final _greatCircleDistanceRads = _greatCircleDistanceRadsPtr
      .asFunction<double Function(ffi.Pointer<LatLng>, ffi.Pointer<LatLng>)>();

  /// @brief "great circle distance" between pairs of LatLng points in
  /// kilometers
  double greatCircleDistanceKm(
    ffi.Pointer<LatLng> a,
    ffi.Pointer<LatLng> b,
  ) {
    return _greatCircleDistanceKm(
      a,
      b,
    );
  }

  late final _greatCircleDistanceKmPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<LatLng>,
              ffi.Pointer<LatLng>)>>('greatCircleDistanceKm');
  late final _greatCircleDistanceKm = _greatCircleDistanceKmPtr
      .asFunction<double Function(ffi.Pointer<LatLng>, ffi.Pointer<LatLng>)>();

  /// @brief "great circle distance" between pairs of LatLng points in meters
  double greatCircleDistanceM(
    ffi.Pointer<LatLng> a,
    ffi.Pointer<LatLng> b,
  ) {
    return _greatCircleDistanceM(
      a,
      b,
    );
  }

  late final _greatCircleDistanceMPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<LatLng>,
              ffi.Pointer<LatLng>)>>('greatCircleDistanceM');
  late final _greatCircleDistanceM = _greatCircleDistanceMPtr
      .asFunction<double Function(ffi.Pointer<LatLng>, ffi.Pointer<LatLng>)>();

  /// @defgroup getHexagonAreaAvg getHexagonAreaAvg
  /// Functions for getHexagonAreaAvg
  /// @{
  /// /
  /// /** @brief average hexagon area in square kilometers (excludes pentagons)
  int getHexagonAreaAvgKm2(
    int res,
    ffi.Pointer<ffi.Double> out,
  ) {
    return _getHexagonAreaAvgKm2(
      res,
      out,
    );
  }

  late final _getHexagonAreaAvgKm2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Int, ffi.Pointer<ffi.Double>)>>('getHexagonAreaAvgKm2');
  late final _getHexagonAreaAvgKm2 = _getHexagonAreaAvgKm2Ptr
      .asFunction<int Function(int, ffi.Pointer<ffi.Double>)>();

  /// @brief average hexagon area in square meters (excludes pentagons)
  int getHexagonAreaAvgM2(
    int res,
    ffi.Pointer<ffi.Double> out,
  ) {
    return _getHexagonAreaAvgM2(
      res,
      out,
    );
  }

  late final _getHexagonAreaAvgM2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Int, ffi.Pointer<ffi.Double>)>>('getHexagonAreaAvgM2');
  late final _getHexagonAreaAvgM2 = _getHexagonAreaAvgM2Ptr
      .asFunction<int Function(int, ffi.Pointer<ffi.Double>)>();

  /// @defgroup cellArea cellArea
  /// Functions for cellArea
  /// @{
  /// /
  /// /** @brief exact area for a specific cell (hexagon or pentagon) in radians^2
  int cellAreaRads2(
    int h,
    ffi.Pointer<ffi.Double> out,
  ) {
    return _cellAreaRads2(
      h,
      out,
    );
  }

  late final _cellAreaRads2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Uint64, ffi.Pointer<ffi.Double>)>>('cellAreaRads2');
  late final _cellAreaRads2 = _cellAreaRads2Ptr
      .asFunction<int Function(int, ffi.Pointer<ffi.Double>)>();

  /// @brief exact area for a specific cell (hexagon or pentagon) in kilometers^2
  int cellAreaKm2(
    int h,
    ffi.Pointer<ffi.Double> out,
  ) {
    return _cellAreaKm2(
      h,
      out,
    );
  }

  late final _cellAreaKm2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Uint64, ffi.Pointer<ffi.Double>)>>('cellAreaKm2');
  late final _cellAreaKm2 =
      _cellAreaKm2Ptr.asFunction<int Function(int, ffi.Pointer<ffi.Double>)>();

  /// @brief exact area for a specific cell (hexagon or pentagon) in meters^2
  int cellAreaM2(
    int h,
    ffi.Pointer<ffi.Double> out,
  ) {
    return _cellAreaM2(
      h,
      out,
    );
  }

  late final _cellAreaM2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Uint64, ffi.Pointer<ffi.Double>)>>('cellAreaM2');
  late final _cellAreaM2 =
      _cellAreaM2Ptr.asFunction<int Function(int, ffi.Pointer<ffi.Double>)>();

  /// @defgroup getHexagonEdgeLengthAvg getHexagonEdgeLengthAvg
  /// Functions for getHexagonEdgeLengthAvg
  /// @{
  /// /
  /// /** @brief average hexagon edge length in kilometers (excludes pentagons)
  int getHexagonEdgeLengthAvgKm(
    int res,
    ffi.Pointer<ffi.Double> out,
  ) {
    return _getHexagonEdgeLengthAvgKm(
      res,
      out,
    );
  }

  late final _getHexagonEdgeLengthAvgKmPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Int, ffi.Pointer<ffi.Double>)>>('getHexagonEdgeLengthAvgKm');
  late final _getHexagonEdgeLengthAvgKm = _getHexagonEdgeLengthAvgKmPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Double>)>();

  /// @brief average hexagon edge length in meters (excludes pentagons)
  int getHexagonEdgeLengthAvgM(
    int res,
    ffi.Pointer<ffi.Double> out,
  ) {
    return _getHexagonEdgeLengthAvgM(
      res,
      out,
    );
  }

  late final _getHexagonEdgeLengthAvgMPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Int, ffi.Pointer<ffi.Double>)>>('getHexagonEdgeLengthAvgM');
  late final _getHexagonEdgeLengthAvgM = _getHexagonEdgeLengthAvgMPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Double>)>();

  /// @defgroup edgeLength edgeLength
  /// Functions for edgeLength
  /// @{
  /// /
  /// /** @brief exact length for a specific directed edge in radians
  int edgeLengthRads(
    int edge,
    ffi.Pointer<ffi.Double> length,
  ) {
    return _edgeLengthRads(
      edge,
      length,
    );
  }

  late final _edgeLengthRadsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Uint64, ffi.Pointer<ffi.Double>)>>('edgeLengthRads');
  late final _edgeLengthRads = _edgeLengthRadsPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Double>)>();

  /// @brief exact length for a specific directed edge in kilometers
  int edgeLengthKm(
    int edge,
    ffi.Pointer<ffi.Double> length,
  ) {
    return _edgeLengthKm(
      edge,
      length,
    );
  }

  late final _edgeLengthKmPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Uint64, ffi.Pointer<ffi.Double>)>>('edgeLengthKm');
  late final _edgeLengthKm =
      _edgeLengthKmPtr.asFunction<int Function(int, ffi.Pointer<ffi.Double>)>();

  /// @brief exact length for a specific directed edge in meters
  int edgeLengthM(
    int edge,
    ffi.Pointer<ffi.Double> length,
  ) {
    return _edgeLengthM(
      edge,
      length,
    );
  }

  late final _edgeLengthMPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Uint64, ffi.Pointer<ffi.Double>)>>('edgeLengthM');
  late final _edgeLengthM =
      _edgeLengthMPtr.asFunction<int Function(int, ffi.Pointer<ffi.Double>)>();

  /// @defgroup getNumCells getNumCells
  /// Functions for getNumCells
  /// @{
  /// /
  /// /** @brief number of cells (hexagons and pentagons) for a given resolution
  ///
  /// It works out to be `2 + 120*7^r` for resolution `r`.
  ///
  /// # Mathematical notes
  ///
  /// Let h(n) be the number of children n levels below
  /// a single *hexagon*.
  ///
  /// Then h(n) = 7^n.
  ///
  /// Let p(n) be the number of children n levels below
  /// a single *pentagon*.
  ///
  /// Then p(0) = 1, and p(1) = 6, since each pentagon
  /// has 5 hexagonal immediate children and 1 pentagonal
  /// immediate child.
  ///
  /// In general, we have the recurrence relation
  ///
  /// p(n) = 5*h(n-1) + p(n-1)
  /// = 5*7^(n-1) + p(n-1).
  ///
  /// Working through the recurrence, we get that
  ///
  /// p(n) = 1 + 5*\sum_{k=1}^n 7^{k-1}
  /// = 1 + 5*(7^n - 1)/6,
  ///
  /// using the closed form for a geometric series.
  ///
  /// Using the closed forms for h(n) and p(n), we can
  /// get a closed form for the total number of cells
  /// at resolution r:
  ///
  /// c(r) = 12*p(r) + 110*h(r)
  /// = 2 + 120*7^r.
  ///
  ///
  /// @param   res  H3 cell resolution
  ///
  /// @return       number of cells at resolution `res`
  int getNumCells(
    int res,
    ffi.Pointer<ffi.Int64> out,
  ) {
    return _getNumCells(
      res,
      out,
    );
  }

  late final _getNumCellsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(ffi.Int, ffi.Pointer<ffi.Int64>)>>('getNumCells');
  late final _getNumCells =
      _getNumCellsPtr.asFunction<int Function(int, ffi.Pointer<ffi.Int64>)>();

  /// @defgroup getRes0Cells getRes0Cells
  /// Functions for getRes0Cells
  /// @{
  /// /
  /// /** @brief returns the number of resolution 0 cells (hexagons and pentagons)
  int res0CellCount() {
    return _res0CellCount();
  }

  late final _res0CellCountPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('res0CellCount');
  late final _res0CellCount = _res0CellCountPtr.asFunction<int Function()>();

  /// @brief provides all base cells in H3Index format
  int getRes0Cells(
    ffi.Pointer<ffi.Uint64> out,
  ) {
    return _getRes0Cells(
      out,
    );
  }

  late final _getRes0CellsPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<ffi.Uint64>)>>(
          'getRes0Cells');
  late final _getRes0Cells =
      _getRes0CellsPtr.asFunction<int Function(ffi.Pointer<ffi.Uint64>)>();

  /// @defgroup getPentagons getPentagons
  /// Functions for getPentagons
  /// @{
  /// /
  /// /** @brief returns the number of pentagons per resolution
  int pentagonCount() {
    return _pentagonCount();
  }

  late final _pentagonCountPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('pentagonCount');
  late final _pentagonCount = _pentagonCountPtr.asFunction<int Function()>();

  /// @brief generates all pentagons at the specified resolution
  int getPentagons(
    int res,
    ffi.Pointer<ffi.Uint64> out,
  ) {
    return _getPentagons(
      res,
      out,
    );
  }

  late final _getPentagonsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Int, ffi.Pointer<ffi.Uint64>)>>('getPentagons');
  late final _getPentagons =
      _getPentagonsPtr.asFunction<int Function(int, ffi.Pointer<ffi.Uint64>)>();

  /// @defgroup getResolution getResolution
  /// Functions for getResolution
  /// @{
  /// /
  /// /** @brief returns the resolution of the provided H3 index
  /// Works on both cells and directed edges.
  int getResolution(
    int h,
  ) {
    return _getResolution(
      h,
    );
  }

  late final _getResolutionPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64)>>(
          'getResolution');
  late final _getResolution = _getResolutionPtr.asFunction<int Function(int)>();

  /// @defgroup getBaseCellNumber getBaseCellNumber
  /// Functions for getBaseCellNumber
  /// @{
  /// /
  /// /** @brief returns the base cell "number" (0 to 121) of the provided H3 cell
  ///
  /// Note: Technically works on H3 edges, but will return base cell of the
  /// origin cell.
  int getBaseCellNumber(
    int h,
  ) {
    return _getBaseCellNumber(
      h,
    );
  }

  late final _getBaseCellNumberPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64)>>(
          'getBaseCellNumber');
  late final _getBaseCellNumber =
      _getBaseCellNumberPtr.asFunction<int Function(int)>();

  /// @defgroup stringToH3 stringToH3
  /// Functions for stringToH3
  /// @{
  /// /
  /// /** @brief converts the canonical string format to H3Index format
  int stringToH3(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Uint64> out,
  ) {
    return _stringToH3(
      str,
      out,
    );
  }

  late final _stringToH3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Uint64>)>>('stringToH3');
  late final _stringToH3 = _stringToH3Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Uint64>)>();

  /// @defgroup h3ToString h3ToString
  /// Functions for h3ToString
  /// @{
  /// /
  /// /** @brief converts an H3Index to a canonical string
  int h3ToString(
    int h,
    ffi.Pointer<ffi.Char> str,
    int sz,
  ) {
    return _h3ToString(
      h,
      str,
      sz,
    );
  }

  late final _h3ToStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Uint64, ffi.Pointer<ffi.Char>, ffi.Size)>>('h3ToString');
  late final _h3ToString = _h3ToStringPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  /// @defgroup isValidCell isValidCell
  /// Functions for isValidCell
  /// @{
  /// /
  /// /** @brief confirms if an H3Index is a valid cell (hexagon or pentagon)
  /// In particular, returns 0 (False) for H3 directed edges or invalid data
  int isValidCell(
    int h,
  ) {
    return _isValidCell(
      h,
    );
  }

  late final _isValidCellPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64)>>('isValidCell');
  late final _isValidCell = _isValidCellPtr.asFunction<int Function(int)>();

  /// @defgroup cellToParent cellToParent
  /// Functions for cellToParent
  /// @{
  /// /
  /// /** @brief returns the parent (or grandparent, etc) cell of the given cell
  int cellToParent(
    int h,
    int parentRes,
    ffi.Pointer<ffi.Uint64> parent,
  ) {
    return _cellToParent(
      h,
      parentRes,
      parent,
    );
  }

  late final _cellToParentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Uint64, ffi.Int, ffi.Pointer<ffi.Uint64>)>>('cellToParent');
  late final _cellToParent = _cellToParentPtr
      .asFunction<int Function(int, int, ffi.Pointer<ffi.Uint64>)>();

  /// @defgroup cellToChildren cellToChildren
  /// Functions for cellToChildren
  /// @{
  /// /
  /// /** @brief determines the exact number of children (or grandchildren, etc)
  /// that would be returned for the given cell
  int cellToChildrenSize(
    int h,
    int childRes,
    ffi.Pointer<ffi.Int64> out,
  ) {
    return _cellToChildrenSize(
      h,
      childRes,
      out,
    );
  }

  late final _cellToChildrenSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(ffi.Uint64, ffi.Int,
              ffi.Pointer<ffi.Int64>)>>('cellToChildrenSize');
  late final _cellToChildrenSize = _cellToChildrenSizePtr
      .asFunction<int Function(int, int, ffi.Pointer<ffi.Int64>)>();

  /// @brief provides the children (or grandchildren, etc) of the given cell
  int cellToChildren(
    int h,
    int childRes,
    ffi.Pointer<ffi.Uint64> children,
  ) {
    return _cellToChildren(
      h,
      childRes,
      children,
    );
  }

  late final _cellToChildrenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Uint64, ffi.Int, ffi.Pointer<ffi.Uint64>)>>('cellToChildren');
  late final _cellToChildren = _cellToChildrenPtr
      .asFunction<int Function(int, int, ffi.Pointer<ffi.Uint64>)>();

  /// @defgroup cellToCenterChild cellToCenterChild
  /// Functions for cellToCenterChild
  /// @{
  /// /
  /// /** @brief returns the center child of the given cell at the specified
  /// resolution
  int cellToCenterChild(
    int h,
    int childRes,
    ffi.Pointer<ffi.Uint64> child,
  ) {
    return _cellToCenterChild(
      h,
      childRes,
      child,
    );
  }

  late final _cellToCenterChildPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(ffi.Uint64, ffi.Int,
              ffi.Pointer<ffi.Uint64>)>>('cellToCenterChild');
  late final _cellToCenterChild = _cellToCenterChildPtr
      .asFunction<int Function(int, int, ffi.Pointer<ffi.Uint64>)>();

  /// @defgroup cellToChildPos cellToChildPos
  /// Functions for cellToChildPos
  /// @{
  /// /
  /// /** @brief Returns the position of the cell within an ordered list of all
  /// children of the cell's parent at the specified resolution
  int cellToChildPos(
    int child,
    int parentRes,
    ffi.Pointer<ffi.Int64> out,
  ) {
    return _cellToChildPos(
      child,
      parentRes,
      out,
    );
  }

  late final _cellToChildPosPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Uint64, ffi.Int, ffi.Pointer<ffi.Int64>)>>('cellToChildPos');
  late final _cellToChildPos = _cellToChildPosPtr
      .asFunction<int Function(int, int, ffi.Pointer<ffi.Int64>)>();

  /// @defgroup childPosToCell childPosToCell
  /// Functions for childPosToCell
  /// @{
  /// /
  /// /** @brief Returns the child cell at a given position within an ordered list of
  /// all children at the specified resolution
  int childPosToCell(
    int childPos,
    int parent,
    int childRes,
    ffi.Pointer<ffi.Uint64> child,
  ) {
    return _childPosToCell(
      childPos,
      parent,
      childRes,
      child,
    );
  }

  late final _childPosToCellPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(ffi.Int64, ffi.Uint64, ffi.Int,
              ffi.Pointer<ffi.Uint64>)>>('childPosToCell');
  late final _childPosToCell = _childPosToCellPtr
      .asFunction<int Function(int, int, int, ffi.Pointer<ffi.Uint64>)>();

  /// @defgroup compactCells compactCells
  /// Functions for compactCells
  /// @{
  /// /
  /// /** @brief compacts the given set of hexagons as best as possible
  int compactCells(
    ffi.Pointer<ffi.Uint64> h3Set,
    ffi.Pointer<ffi.Uint64> compactedSet,
    int numHexes,
  ) {
    return _compactCells(
      h3Set,
      compactedSet,
      numHexes,
    );
  }

  late final _compactCellsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(ffi.Pointer<ffi.Uint64>, ffi.Pointer<ffi.Uint64>,
              ffi.Int64)>>('compactCells');
  late final _compactCells = _compactCellsPtr.asFunction<
      int Function(ffi.Pointer<ffi.Uint64>, ffi.Pointer<ffi.Uint64>, int)>();

  /// @defgroup uncompactCells uncompactCells
  /// Functions for uncompactCells
  /// @{
  /// /
  /// /** @brief determines the exact number of hexagons that will be uncompacted
  /// from the compacted set
  int uncompactCellsSize(
    ffi.Pointer<ffi.Uint64> compactedSet,
    int numCompacted,
    int res,
    ffi.Pointer<ffi.Int64> out,
  ) {
    return _uncompactCellsSize(
      compactedSet,
      numCompacted,
      res,
      out,
    );
  }

  late final _uncompactCellsSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(ffi.Pointer<ffi.Uint64>, ffi.Int64, ffi.Int,
              ffi.Pointer<ffi.Int64>)>>('uncompactCellsSize');
  late final _uncompactCellsSize = _uncompactCellsSizePtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Uint64>, int, int, ffi.Pointer<ffi.Int64>)>();

  /// @brief uncompacts the compacted hexagon set
  int uncompactCells(
    ffi.Pointer<ffi.Uint64> compactedSet,
    int numCompacted,
    ffi.Pointer<ffi.Uint64> outSet,
    int numOut,
    int res,
  ) {
    return _uncompactCells(
      compactedSet,
      numCompacted,
      outSet,
      numOut,
      res,
    );
  }

  late final _uncompactCellsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(ffi.Pointer<ffi.Uint64>, ffi.Int64,
              ffi.Pointer<ffi.Uint64>, ffi.Int64, ffi.Int)>>('uncompactCells');
  late final _uncompactCells = _uncompactCellsPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Uint64>, int, ffi.Pointer<ffi.Uint64>, int, int)>();

  /// @defgroup isResClassIII isResClassIII
  /// Functions for isResClassIII
  /// @{
  /// /
  /// /** @brief determines if a hexagon is Class III (or Class II)
  int isResClassIII(
    int h,
  ) {
    return _isResClassIII(
      h,
    );
  }

  late final _isResClassIIIPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64)>>(
          'isResClassIII');
  late final _isResClassIII = _isResClassIIIPtr.asFunction<int Function(int)>();

  /// @defgroup isPentagon isPentagon
  /// Functions for isPentagon
  /// @{
  /// /
  /// /** @brief determines if an H3 cell is a pentagon
  int isPentagon(
    int h,
  ) {
    return _isPentagon(
      h,
    );
  }

  late final _isPentagonPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64)>>('isPentagon');
  late final _isPentagon = _isPentagonPtr.asFunction<int Function(int)>();

  /// @defgroup getIcosahedronFaces getIcosahedronFaces
  /// Functions for getIcosahedronFaces
  /// @{
  /// /
  /// /** @brief Max number of icosahedron faces intersected by an index
  int maxFaceCount(
    int h3,
    ffi.Pointer<ffi.Int> out,
  ) {
    return _maxFaceCount(
      h3,
      out,
    );
  }

  late final _maxFaceCountPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Uint64, ffi.Pointer<ffi.Int>)>>('maxFaceCount');
  late final _maxFaceCount =
      _maxFaceCountPtr.asFunction<int Function(int, ffi.Pointer<ffi.Int>)>();

  /// @brief Find all icosahedron faces intersected by a given H3 index
  int getIcosahedronFaces(
    int h3,
    ffi.Pointer<ffi.Int> out,
  ) {
    return _getIcosahedronFaces(
      h3,
      out,
    );
  }

  late final _getIcosahedronFacesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Uint64, ffi.Pointer<ffi.Int>)>>('getIcosahedronFaces');
  late final _getIcosahedronFaces = _getIcosahedronFacesPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Int>)>();

  /// @defgroup areNeighborCells areNeighborCells
  /// Functions for areNeighborCells
  /// @{
  /// /
  /// /** @brief returns whether or not the provided hexagons border
  int areNeighborCells(
    int origin,
    int destination,
    ffi.Pointer<ffi.Int> out,
  ) {
    return _areNeighborCells(
      origin,
      destination,
      out,
    );
  }

  late final _areNeighborCellsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(ffi.Uint64, ffi.Uint64,
              ffi.Pointer<ffi.Int>)>>('areNeighborCells');
  late final _areNeighborCells = _areNeighborCellsPtr
      .asFunction<int Function(int, int, ffi.Pointer<ffi.Int>)>();

  /// @defgroup cellsToDirectedEdge cellsToDirectedEdge
  /// Functions for cellsToDirectedEdge
  /// @{
  /// /
  /// /** @brief returns the directed edge H3Index for the specified origin and
  /// destination
  int cellsToDirectedEdge(
    int origin,
    int destination,
    ffi.Pointer<ffi.Uint64> out,
  ) {
    return _cellsToDirectedEdge(
      origin,
      destination,
      out,
    );
  }

  late final _cellsToDirectedEdgePtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(ffi.Uint64, ffi.Uint64,
              ffi.Pointer<ffi.Uint64>)>>('cellsToDirectedEdge');
  late final _cellsToDirectedEdge = _cellsToDirectedEdgePtr
      .asFunction<int Function(int, int, ffi.Pointer<ffi.Uint64>)>();

  /// @defgroup isValidDirectedEdge isValidDirectedEdge
  /// Functions for isValidDirectedEdge
  /// @{
  /// /
  /// /** @brief returns whether the H3Index is a valid directed edge
  int isValidDirectedEdge(
    int edge,
  ) {
    return _isValidDirectedEdge(
      edge,
    );
  }

  late final _isValidDirectedEdgePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64)>>(
          'isValidDirectedEdge');
  late final _isValidDirectedEdge =
      _isValidDirectedEdgePtr.asFunction<int Function(int)>();

  /// @defgroup getDirectedEdgeOrigin \
  /// getDirectedEdgeOrigin
  /// Functions for getDirectedEdgeOrigin
  /// @{
  /// /
  /// /** @brief Returns the origin hexagon H3Index from the directed edge
  /// H3Index
  int getDirectedEdgeOrigin(
    int edge,
    ffi.Pointer<ffi.Uint64> out,
  ) {
    return _getDirectedEdgeOrigin(
      edge,
      out,
    );
  }

  late final _getDirectedEdgeOriginPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Uint64, ffi.Pointer<ffi.Uint64>)>>('getDirectedEdgeOrigin');
  late final _getDirectedEdgeOrigin = _getDirectedEdgeOriginPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Uint64>)>();

  /// @defgroup getDirectedEdgeDestination \
  /// getDirectedEdgeDestination
  /// Functions for getDirectedEdgeDestination
  /// @{
  /// /
  /// /** @brief Returns the destination hexagon H3Index from the directed edge
  /// H3Index
  int getDirectedEdgeDestination(
    int edge,
    ffi.Pointer<ffi.Uint64> out,
  ) {
    return _getDirectedEdgeDestination(
      edge,
      out,
    );
  }

  late final _getDirectedEdgeDestinationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(ffi.Uint64,
              ffi.Pointer<ffi.Uint64>)>>('getDirectedEdgeDestination');
  late final _getDirectedEdgeDestination = _getDirectedEdgeDestinationPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Uint64>)>();

  /// @defgroup directedEdgeToCells \
  /// directedEdgeToCells
  /// Functions for directedEdgeToCells
  /// @{
  /// /
  /// /** @brief Returns the origin and destination hexagons from the directed
  /// edge H3Index
  int directedEdgeToCells(
    int edge,
    ffi.Pointer<ffi.Uint64> originDestination,
  ) {
    return _directedEdgeToCells(
      edge,
      originDestination,
    );
  }

  late final _directedEdgeToCellsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Uint64, ffi.Pointer<ffi.Uint64>)>>('directedEdgeToCells');
  late final _directedEdgeToCells = _directedEdgeToCellsPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Uint64>)>();

  /// @defgroup originToDirectedEdges \
  /// originToDirectedEdges
  /// Functions for originToDirectedEdges
  /// @{
  /// /
  /// /** @brief Returns the 6 (or 5 for pentagons) edges associated with the H3Index
  int originToDirectedEdges(
    int origin,
    ffi.Pointer<ffi.Uint64> edges,
  ) {
    return _originToDirectedEdges(
      origin,
      edges,
    );
  }

  late final _originToDirectedEdgesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Uint64, ffi.Pointer<ffi.Uint64>)>>('originToDirectedEdges');
  late final _originToDirectedEdges = _originToDirectedEdgesPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Uint64>)>();

  /// @defgroup directedEdgeToBoundary directedEdgeToBoundary
  /// Functions for directedEdgeToBoundary
  /// @{
  /// /
  /// /** @brief Returns the CellBoundary containing the coordinates of the edge
  int directedEdgeToBoundary(
    int edge,
    ffi.Pointer<CellBoundary> gb,
  ) {
    return _directedEdgeToBoundary(
      edge,
      gb,
    );
  }

  late final _directedEdgeToBoundaryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(ffi.Uint64,
              ffi.Pointer<CellBoundary>)>>('directedEdgeToBoundary');
  late final _directedEdgeToBoundary = _directedEdgeToBoundaryPtr
      .asFunction<int Function(int, ffi.Pointer<CellBoundary>)>();

  /// @defgroup cellToVertex cellToVertex
  /// Functions for cellToVertex
  /// @{
  /// /
  /// /** @brief Returns a single vertex for a given cell, as an H3 index
  int cellToVertex(
    int origin,
    int vertexNum,
    ffi.Pointer<ffi.Uint64> out,
  ) {
    return _cellToVertex(
      origin,
      vertexNum,
      out,
    );
  }

  late final _cellToVertexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Uint64, ffi.Int, ffi.Pointer<ffi.Uint64>)>>('cellToVertex');
  late final _cellToVertex = _cellToVertexPtr
      .asFunction<int Function(int, int, ffi.Pointer<ffi.Uint64>)>();

  /// @defgroup cellToVertexes cellToVertexes
  /// Functions for cellToVertexes
  /// @{
  /// /
  /// /** @brief Returns all vertexes for a given cell, as H3 indexes
  int cellToVertexes(
    int origin,
    ffi.Pointer<ffi.Uint64> vertexes,
  ) {
    return _cellToVertexes(
      origin,
      vertexes,
    );
  }

  late final _cellToVertexesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Uint64, ffi.Pointer<ffi.Uint64>)>>('cellToVertexes');
  late final _cellToVertexes = _cellToVertexesPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Uint64>)>();

  /// @defgroup vertexToLatLng vertexToLatLng
  /// Functions for vertexToLatLng
  /// @{
  /// /
  /// /** @brief Returns a single vertex for a given cell, as an H3 index
  int vertexToLatLng(
    int vertex,
    ffi.Pointer<LatLng> point,
  ) {
    return _vertexToLatLng(
      vertex,
      point,
    );
  }

  late final _vertexToLatLngPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Uint64, ffi.Pointer<LatLng>)>>('vertexToLatLng');
  late final _vertexToLatLng =
      _vertexToLatLngPtr.asFunction<int Function(int, ffi.Pointer<LatLng>)>();

  /// @defgroup isValidVertex isValidVertex
  /// Functions for isValidVertex
  /// @{
  /// /
  /// /** @brief Whether the input is a valid H3 vertex
  int isValidVertex(
    int vertex,
  ) {
    return _isValidVertex(
      vertex,
    );
  }

  late final _isValidVertexPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64)>>(
          'isValidVertex');
  late final _isValidVertex = _isValidVertexPtr.asFunction<int Function(int)>();

  /// @defgroup gridDistance gridDistance
  /// Functions for gridDistance
  /// @{
  /// /
  /// /** @brief Returns grid distance between two indexes
  int gridDistance(
    int origin,
    int h3,
    ffi.Pointer<ffi.Int64> distance,
  ) {
    return _gridDistance(
      origin,
      h3,
      distance,
    );
  }

  late final _gridDistancePtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Uint64, ffi.Uint64, ffi.Pointer<ffi.Int64>)>>('gridDistance');
  late final _gridDistance = _gridDistancePtr
      .asFunction<int Function(int, int, ffi.Pointer<ffi.Int64>)>();

  /// @defgroup gridPathCells gridPathCells
  /// Functions for gridPathCells
  /// @{
  /// /
  /// /** @brief Number of indexes in a line connecting two indexes
  int gridPathCellsSize(
    int start,
    int end,
    ffi.Pointer<ffi.Int64> size,
  ) {
    return _gridPathCellsSize(
      start,
      end,
      size,
    );
  }

  late final _gridPathCellsSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(ffi.Uint64, ffi.Uint64,
              ffi.Pointer<ffi.Int64>)>>('gridPathCellsSize');
  late final _gridPathCellsSize = _gridPathCellsSizePtr
      .asFunction<int Function(int, int, ffi.Pointer<ffi.Int64>)>();

  /// @brief Line of h3 indexes connecting two indexes
  int gridPathCells(
    int start,
    int end,
    ffi.Pointer<ffi.Uint64> out,
  ) {
    return _gridPathCells(
      start,
      end,
      out,
    );
  }

  late final _gridPathCellsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(ffi.Uint64, ffi.Uint64,
              ffi.Pointer<ffi.Uint64>)>>('gridPathCells');
  late final _gridPathCells = _gridPathCellsPtr
      .asFunction<int Function(int, int, ffi.Pointer<ffi.Uint64>)>();

  /// @defgroup cellToLocalIj cellToLocalIj
  /// Functions for cellToLocalIj
  /// @{
  /// /
  /// /** @brief Returns two dimensional coordinates for the given index
  int cellToLocalIj(
    int origin,
    int h3,
    int mode,
    ffi.Pointer<CoordIJ> out,
  ) {
    return _cellToLocalIj(
      origin,
      h3,
      mode,
      out,
    );
  }

  late final _cellToLocalIjPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(ffi.Uint64, ffi.Uint64, ffi.Uint32,
              ffi.Pointer<CoordIJ>)>>('cellToLocalIj');
  late final _cellToLocalIj = _cellToLocalIjPtr
      .asFunction<int Function(int, int, int, ffi.Pointer<CoordIJ>)>();

  /// @defgroup localIjToCell localIjToCell
  /// Functions for localIjToCell
  /// @{
  /// /
  /// /** @brief Returns index for the given two dimensional coordinates
  int localIjToCell(
    int origin,
    ffi.Pointer<CoordIJ> ij,
    int mode,
    ffi.Pointer<ffi.Uint64> out,
  ) {
    return _localIjToCell(
      origin,
      ij,
      mode,
      out,
    );
  }

  late final _localIjToCellPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(ffi.Uint64, ffi.Pointer<CoordIJ>, ffi.Uint32,
              ffi.Pointer<ffi.Uint64>)>>('localIjToCell');
  late final _localIjToCell = _localIjToCellPtr.asFunction<
      int Function(int, ffi.Pointer<CoordIJ>, int, ffi.Pointer<ffi.Uint64>)>();
}

/// @struct LatLng
/// @brief latitude/longitude in radians
final class LatLng extends ffi.Struct {
  /// < latitude in radians
  @ffi.Double()
  external double lat;

  /// < longitude in radians
  @ffi.Double()
  external double lng;
}

/// @struct CellBoundary
/// @brief cell boundary in latitude/longitude
final class CellBoundary extends ffi.Struct {
  /// < number of vertices
  @ffi.Int()
  external int numVerts;

  /// < vertices in ccw order
  @ffi.Array.multi([10])
  external ffi.Array<LatLng> verts;
}

/// @struct GeoLoop
/// @brief similar to CellBoundary, but requires more alloc work
final class GeoLoop extends ffi.Struct {
  @ffi.Int()
  external int numVerts;

  external ffi.Pointer<LatLng> verts;
}

/// @struct GeoPolygon
/// @brief Simplified core of GeoJSON Polygon coordinates definition
final class GeoPolygon extends ffi.Struct {
  /// < exterior boundary of the polygon
  external GeoLoop geoloop;

  /// < number of elements in the array pointed to by holes
  @ffi.Int()
  external int numHoles;

  /// < interior boundaries (holes) in the polygon
  external ffi.Pointer<GeoLoop> holes;
}

final class LinkedLatLng extends ffi.Struct {
  external LatLng vertex;

  external ffi.Pointer<LinkedLatLng> next;
}

final class LinkedGeoLoop extends ffi.Struct {
  external ffi.Pointer<LinkedLatLng> first;

  external ffi.Pointer<LinkedLatLng> last;

  external ffi.Pointer<LinkedGeoLoop> next;
}

final class LinkedGeoPolygon extends ffi.Struct {
  external ffi.Pointer<LinkedGeoLoop> first;

  external ffi.Pointer<LinkedGeoLoop> last;

  external ffi.Pointer<LinkedGeoPolygon> next;
}

/// @struct CoordIJ
/// @brief IJ hexagon coordinates
///
/// Each axis is spaced 120 degrees apart.
final class CoordIJ extends ffi.Struct {
  /// < i component
  @ffi.Int()
  external int i;

  /// < j component
  @ffi.Int()
  external int j;
}
